#include "binary_trees.h"
#define MAX(a, b) (((a) >= (b)) ? (a) : (b))

/**
 * _pow_recursion - return x to power of y
 * @x: base.
 * @y: power.
 * Return: x ** y.
 */
int _pow(int x, int y)
{
	if (y > 0)
	{
		return (_pow(x, y - 1) * x);
	}
	else if (y < 0)
	{
		return (-1);
	}
	else
		return (1);
}

/**
 * height - measures the max height of a binary tree
 * @node: pointer to the root node of the tree to measure the height.
 * Return: return the max height
 **/
int height(const binary_tree_t *node)
{
	int l = 0, r = 0;

	if (node->left)
		l = height(node->left);
	if (node->right)
		r = height(node->right);
	return (1 + MAX(l, r));
}

/**
 * binary_tree_is_complete - checks if a binary tree is complete.
 * @tree: pointer to the root node of the tree to check.
 * Return: 1 if complete, else 0. If tree is NULL return 0.
 */
int binary_tree_is_complete(const binary_tree_t *tree)
{
	int h = 0, i = 0, j = 0;
	binary_tree_t *arr[1024], *node;

	if (tree == NULL)
		return (0);
	for (i = 0; i < 1024; i++)
		arr[i] = NULL;
	h = height(tree) - 1;
	i = 0;
	arr[i] = (binary_tree_t *)tree;
	j = i;
	while (arr[i] != NULL)
	{
		node = arr[i];
		if (node->left != NULL)
		{
			j++;
			arr[j] = node->left;
		}
		if (node->right != NULL)
		{
			j++;
			arr[j] = node->right;
		}
		i++;
	}
	for (i = _pow(2, h) - 1; i < _pow(2, h + 1) - 1; i++)
	{
		if (arr[i] == NULL || arr[i]->right || arr[i]->left)
			return (0);
	}
	return (1);
}
